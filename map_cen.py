# -*- coding: utf-8 -*-
"""
/***************************************************************************
 MapCEN
                                 A QGIS plugin
 Mise en page automatique (ajout de la l√©gende, d'une barre d'√©chelle, de la fl√®che du nord, d'un titre) d'un projet QGIS.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2022-05-20
        git sha              : $Format:%H$
        copyright            : (C) 2022 by Romain Montillet
        email                : r.montillet@cen-na.org
 ***************************************************************************/
/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, Qt, QSize, QThread
from qgis.PyQt.QtGui import QFont, QIcon, QMovie, QColor, QPixmap
from qgis.PyQt.QtWidgets import QWidget, QAction, QMessageBox, QLabel, QPushButton, QFileDialog, QDialog, QVBoxLayout, QListWidget, QProgressDialog, QProgressBar
from qgis.utils import iface
from qgis.gui import QgsMapToolPan

from qgis.core import (
    Qgis, QgsApplication, QgsRasterLayer, QgsVectorLayer,
    QgsProject, QgsFeatureRequest, QgsCoordinateReferenceSystem, QgsSymbol, 
    QgsRuleBasedRenderer, QgsLayoutItemPicture, QgsLayoutItemLabel, 
    QgsLayerTree, QgsLayoutItemLegend, QgsCoordinateTransform,
    QgsUnitTypes, QgsLayoutSize, QgsLayoutPoint, QgsPrintLayout,
    QgsGeometryGeneratorSymbolLayer, QgsWkbTypes, QgsSimpleFillSymbolLayer, QgsLayoutItemMap,
    QgsLayoutItemScaleBar, QgsAggregateCalculator, QgsReadWriteContext,
    QgsLayoutItemPage, QgsLayerTreeGroup, QgsLegendStyle, QgsDataSourceUri, QgsLayoutExporter
)

from qgis.PyQt.QtXml import QDomDocument
# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .map_cen_dialog import MapCENDialog
import os.path
import urllib
from urllib import request, parse
import glob
import socket
import yaml

from datetime import date


from .carto_perimetres_ecologiques import module_perim_eco
from .carto_localisation_generale import module_loc_generale
from .carto_travaux import module_travaux


# V√©rifier la connexion √† internet
try:
    # V√©rifier si l'utilisateur est connect√© √† internet en ouvrant une connexion avec un site web
    host = socket.gethostbyname("www.google.com")
    s = socket.create_connection((host, 80), 2)
    s.close()
except socket.error:
    # Afficher un message si l'utilisateur n'est pas connect√© √† internet
    QMessageBox.warning(None, 'Avertissement',
                        'Vous n\'√™tes actuellement pas connect√© √† internet. Veuillez vous connecter pour pouvoir utiliser MapCEN !')

class OptionsWindow(QWidget):
    def __init__(self, parent=None):
        super(OptionsWindow, self).__init__(parent)

        self.setWindowTitle("Options d'export")
        self.setMinimumSize(300,200)
        self.setMaximumSize(300,200)

        titre = QLabel(self)
        titre.setFont(QFont("Calibri",weight=QFont.Bold))
        titre.move(70, 20)
        titre.setText("R√©solution de la carte √† exporter :")
        a = QPushButton("Haute r√©solution", self)
        a.move(90, 50)
        a.setMinimumSize(120, 25)
        a.setMaximumSize(120, 25)
        b = QPushButton("Moyenne r√©solution", self)
        b.move(90, 90)
        b.setMinimumSize(120, 25)
        b.setMaximumSize(120, 25)
        c = QPushButton("Basse r√©solution", self)
        c.move(90, 130)
        c.setMinimumSize(120, 25)
        c.setMaximumSize(120, 25)

        a.clicked.connect(lambda: self.set_resolution(300))
        b.clicked.connect(lambda: self.set_resolution(200))
        c.clicked.connect(lambda: self.set_resolution(100))

        # OptionsWindow().exec_()

        self.dlg = MapCENDialog()
        # self.module_loc_generale = module_loc_generale()

    def set_resolution(self, resolution):
        self.a = resolution
        
        # Fermer imm√©diatement la fen√™tre d'options
        self.close()
        
        # Demander √† l'utilisateur o√π enregistrer l'image
        fileName = QFileDialog.getSaveFileName(None, 'Sauvegarder en jpg', '', filter='*.jpg')
        if not fileName or not fileName[0]:
            return  # L'utilisateur a annul√©
            
        dossier_sauvegarde = fileName[0]
        
        # Cr√©er une bo√Æte de dialogue personnalis√©e au lieu de QProgressDialog
        progress_dialog = QDialog(None, Qt.WindowStaysOnTopHint)
        progress_dialog.setWindowTitle("Export en cours")
        progress_dialog.setWindowModality(Qt.WindowModal)  # Emp√™che l'acc√®s √† d'autres fen√™tres
        progress_dialog.resize(400, 200)
        
        # Cr√©er la mise en page pour notre fen√™tre
        layout = QVBoxLayout(progress_dialog)
        
        # Titre principal
        title_label = QLabel("Export de la carte en cours...")
        title_label.setStyleSheet("font-size: 14px; font-weight: bold; margin-bottom: 10px;")
        layout.addWidget(title_label)
        
        # Barre de progression
        progress_bar = QProgressBar(progress_dialog)
        progress_bar.setMinimum(0)
        progress_bar.setMaximum(100)
        progress_bar.setValue(10)  # D√©marrer √† 10%
        layout.addWidget(progress_bar)
        
        # Message d'information
        info_label = QLabel("Initialisation de l'export...")
        layout.addWidget(info_label)
        
        # Message d'avertissement sur la dur√©e
        warning_label = QLabel("L'export peut prendre jusqu'√† 30 secondes pour les cartes en haute r√©solution.\nLe curseur peut sembler bloqu√©, mais le processus est bien en cours.")
        warning_label.setStyleSheet("font-size: 10px; color: gray; margin-top: 10px;")
        layout.addWidget(warning_label)
        
        # Afficher le dialogue
        progress_dialog.show()
        QgsApplication.processEvents()
        
        try:
            # R√©cup√©rer toutes les mises en page disponibles
            layouts = QgsProject.instance().layoutManager().layouts()
            progress_bar.setValue(20)
            info_label.setText("Chargement des mises en page...")
            QgsApplication.processEvents()
            
            if not layouts:
                progress_dialog.close()
                QMessageBox.warning(None, "Erreur", "Aucune mise en page n'a √©t√© trouv√©e dans le projet.")
                return
                
            # Utiliser la premi√®re mise en page disponible
            dialog_layout = layouts[0]  # Renomm√© pour √©viter la confusion avec le QVBoxLayout
            progress_bar.setValue(30)
            info_label.setText(f"Pr√©paration de la mise en page : {dialog_layout.name()}")
            QgsApplication.processEvents()
            
            # Afficher quelle mise en page est utilis√©e
            print(f"Utilisation de la mise en page: {dialog_layout.name()}")
            
            if not dialog_layout:
                progress_dialog.close()
                QMessageBox.warning(None, "Erreur", "La mise en page n'a pas pu √™tre trouv√©e. Veuillez v√©rifier sa disponibilit√© dans le gestionnaire de mises en page.")
                return
                
            # Configurer la r√©solution d'export
            progress_bar.setValue(50)
            QgsApplication.processEvents()
            exporter = QgsLayoutExporter(dialog_layout)
            settings = QgsLayoutExporter.ImageExportSettings()
            settings.dpi = resolution
            
            # Avec notre dialogue personnalis√©, pas besoin de d√©sactiver un bouton d'annulation
            # car nous n'en avons pas ajout√©. Notre dialogue est modal et sans bouton d'annulation.
            
            # Animation de la barre pour montrer que le processus est en cours
            for i in range(70, 85):
                progress_bar.setValue(i)
                info_label.setText(f"G√©n√©ration de l'image en cours... ({i}%)")
                QgsApplication.processEvents()
                # Petite pause pour l'animation
                QThread.msleep(50)  # 50ms pause
                
            # Exporter l'image (op√©ration blocante)
            for i in range(85, 95):
                progress_bar.setValue(i)
                info_label.setText(f"Finalisation de l'export... ({i}%)")
                QgsApplication.processEvents()
                # Petite pause pour l'animation
                QThread.msleep(50)  # 50ms pause
            
            # D√©sactiver le bouton de fermeture (s'il est visible)
            progress_dialog.setWindowFlags(progress_dialog.windowFlags() & ~Qt.WindowCloseButtonHint)
            progress_dialog.show() # N√©cessaire apr√®s avoir modifi√© les flags
            QgsApplication.processEvents()
            
            # Mise √† jour des informations avant l'export
            info_label.setText("Export en cours... Cela peut prendre jusqu'√† 30 secondes.")
            warning_label.setText("Veuillez ne pas fermer cette fen√™tre. Le plugin peut sembler fig√© pendant l'export.")
            warning_label.setStyleSheet("font-size: 10px; color: #e74c3c; font-weight: bold;")
            QgsApplication.processEvents()
            
            # Ex√©cuter l'export (op√©ration blocante)
            result_img = exporter.exportToImage(dossier_sauvegarde, settings)
            
            # Une fois l'export termin√©
            progress_bar.setValue(98)
            info_label.setText("Export termin√© avec succ√®s!")
            QgsApplication.processEvents()
            
            # Afficher le r√©sultat
            progress_bar.setValue(100)
            info_label.setText("Export termin√© !")
            QgsApplication.processEvents()
            
            if result_img == QgsLayoutExporter.Success:
                progress_dialog.close()
                QMessageBox.information(None, "Export r√©ussi", f"La carte a √©t√© export√©e avec succ√®s en {resolution} DPI.")
            else:
                progress_dialog.close()
                QMessageBox.critical(None, "Erreur d'export", "L'export a √©chou√©. Veuillez v√©rifier le chemin d'enregistrement et r√©essayer.")
                
            print(f"R√©sultat de l'export: {result_img}")  # 0 = export r√©ussi !
        except Exception as e:
            # G√©rer les erreurs potentielles
            progress_dialog.close()
            QMessageBox.critical(None, "Erreur", f"Une erreur s'est produite lors de l'export : {str(e)}")
            print(f"Erreur d'export : {str(e)}")
        finally:
            # S'assurer que la barre de progression est bien ferm√©e
            if progress_dialog and progress_dialog.isVisible():
                progress_dialog.close()
                
            # Nettoyage explicite des ressources pour √©viter les fuites de m√©moire
            try:
                # D√©r√©f√©rencer les objets pour aider le garbage collector
                exporter = None
                dialog_layout = None
                progress_dialog = None
                progress_bar = None
                info_label = None
                warning_label = None
            except:
                pass


class AuthSelectionDialog(QDialog):
    def __init__(self, auth_configs, parent=None):
        super(AuthSelectionDialog, self).__init__(parent)
        self.selected_auth_id = None
        self.auth_config_dict = {}  # Dictionnaire pour stocker l'association entre nom et ID
        
        self.setWindowTitle("S√©lectionner une configuration d'authentification")

        layout = QVBoxLayout()

        # List to display available authentication configurations
        self.list_widget = QListWidget(self)
        for auth_id, auth_config in auth_configs.items():
            auth_name = auth_config.name()  # Obtenir le nom de la configuration
            self.list_widget.addItem(auth_name)
            self.auth_config_dict[auth_name] = auth_id  # Associer le nom √† l'ID

        layout.addWidget(self.list_widget)

        # OK button
        ok_button = QPushButton("OK")
        ok_button.clicked.connect(self.accept_selection)
        layout.addWidget(ok_button)

        self.setLayout(layout)

    def accept_selection(self):
        # Get the selected item from the list
        selected_item = self.list_widget.currentItem()
        if selected_item:
            selected_name = selected_item.text()
            # R√©cup√©rer l'ID associ√© au nom s√©lectionn√©
            self.selected_auth_id = self.auth_config_dict.get(selected_name)
            self.accept()
        else:
            QMessageBox.warning(self, "S√©lection requise", "Veuillez s√©lectionner une configuration d'authentification.")

class MapCEN:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.
        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface

        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'MapCEN_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&MapCEN')
        self.dlg = MapCENDialog()

        self.module_perim_eco = module_perim_eco()
        self.module_perim_eco.dlg = self.dlg

        self.module_loc_generale = module_loc_generale()
        self.module_loc_generale.dlg = self.dlg

        self.module_travaux = module_travaux()
        self.module_travaux.dlg = self.dlg

        # module_perim_eco.dlg = self.dlg
        self.plugin_path = os.path.dirname(__file__)

        self.dlg.commandLinkButton.clicked.connect(self.chargement_qpt)

        self.dlg.comboBox_3.currentIndexChanged.connect(self.initialisation)
        self.dlg.commandLinkButton_3.clicked.connect(self.choose_default_authentication)
        self.dlg.pushButton.clicked.connect(self.ajout_couches)
        self.dlg.commandLinkButton_4.clicked.connect(self.actualisation_emprise)

        self.dlg.commandLinkButton_5.clicked.connect(self.ouverture_composeur)
        self.dlg.commandLinkButton_6.clicked.connect(self.popup_resolution)
        self.dlg.commandLinkButton_7.clicked.connect(self.show_welcome_popup)
        # self.default_project_scale = self.iface.mapCanvas().scale()
        # print("echelle par d√©faut √† l'initilaisation du plugin", self.default_project_scale)

        self.dlg.graphicsView.scale(2.1,2.1)
        self.dlg.graphicsView.setMouseTracking(True)

        self.dlg.horizontalSlider.valueChanged.connect(self.niveau_zoom)
        self.dlg.mComboBox_4.checkedItemsChanged.connect(self.choix_dept)

        self.dlg.comboBox.currentIndexChanged.connect(self.liste_couche_template)

        self.dlg.mComboBox_3.hide()

        self.dlg.comboBox_3.addItems(["MFU", "Localisation de sites", "P√©rim√®tres √©cologiques", "Travaux"])

        self.dlg.comboBox_3.model().item(0).setEnabled(False)
        # self.dlg.lineEdit.textChanged.connect(self.onTextChanged)

        self.dlg.checkBox.stateChanged.connect(self.ajout_code_sites)

        self.dlg.pushButton_2.clicked.connect(self.masquer_parcelles_voisines)

        self.dlg.setMouseTracking(True)
        # self.dlg.mComboBox_4.setEnabled(False)

        self.movie = QMovie(
            str(self.plugin_path) + "/icons/underconstruction.gif")  # r√©cup√©ration du gif via le chemin relatif du plugin
        self.dlg.label_11.setMovie(self.movie)
        self.movie.start()

        tool = QgsMapToolPan(self.iface.mapCanvas())
        tool.canvasReleaseEvent = lambda event: self.function_from_plugin(event)
        self.iface.mapCanvas().setMapTool(tool)

        ## On ajoute le nom des templates √† la liste d√©roulante de l'onglet "mises en page" :
        mises_en_page = []

        for filename in glob.glob(self.plugin_path + "/mises_en_pages/*.qpt"):
            mises_en_page.append(filename)


        for i, filename in enumerate(mises_en_page):
            nom_fichier = os.path.basename(filename)
            self.dlg.comboBox.addItem(nom_fichier)


        self.dlg.radioButton_6.setChecked(True)
        self.dlg.radioButton_7.setChecked(True)


       # Cr√©ez un QLabel pour afficher le GIF
        self.label_loading = QLabel(self.dlg)

        # Configurez le QLabel avec le GIF
        self.loading_gif = QMovie(str(self.plugin_path) + "/icons/loading2.gif")   # Remplacez par le chemin de votre GIF
        self.label_loading.setMovie(self.loading_gif)

        # Sp√©cifiez les dimensions souhait√©es pour redimensionner le GIF
        scaled_width = 191  # D√©finissez la largeur souhait√©e
        scaled_height = 188  # D√©finissez la hauteur souhait√©e
        self.loading_gif.setScaledSize(QSize(scaled_width, scaled_height))

        # Appliquez la taille redimensionn√©e au QLabel
        self.label_loading.resize(scaled_width, scaled_height)

        # Calculez les coordonn√©es pour centrer le GIF dans le plugin
        dlg_width = self.dlg.width()
        dlg_height = self.dlg.height()
        x = (dlg_width - scaled_width) // 2
        y = (dlg_height - scaled_height) // 2

        # Positionnez le QLabel au centre
        self.label_loading.move(x, y)


        self.label_loading.raise_()  # Place au premier plan


        # Je rassemble toutes mes variables que je veux initialiser √† une valeur vide dans un dictionnaire pour qu'elles soient assign√©es √† une valeur √† partir d'une fonction sp√©cifique This approach avoids cluttering your class with many individual variables
        # Je fais √ßa pour √©viter de d'encombrer de faire une liste de course de nombreuses variables individuelles.
        self.template_parameters = {
            'map_size': None,
            'map_position' : None,
            'title_position': None,
            'title_size': None,
            'subtitle_position': None,
            'subtitle_size': None,
            'logo_position': None,
            'logo_size': None,
            'legend_position': None,
            'legend_size': None,
            'scalebar_position': None,
            'scalebar_size': None,
            'north_position': None,
            'north_size': None,
            'credit_text_position': None,
            'credit_text_size': None,
            'credit_text2_position': None,
            'credit_text2_size': None,
            # Add more variables as needed
        }

    def closeEvent(self, event):
        # Appelle ta fonction lors de la fermeture
        print("test")
        # Accepte l'√©v√©nement de fermeture pour fermer la fen√™tre
        
        event.accept()

    def show_welcome_popup(self):
        """
        Affiche une fen√™tre avec une image au d√©marrage, centre l'image et ajoute un texte en dessous.
        """
        # Cr√©er un QDialog (fen√™tre personnalis√©e)
        dialog = QDialog()
        dialog.setWindowTitle("Nouvelle version: MapCEN !")

        # Cr√©er un layout
        layout = QVBoxLayout()

        # Ajouter une image (remplace 'maj_4.5.JPG' par le chemin de ton image)
        label_image = QLabel()
        pixmap = QPixmap(self.plugin_path + "/html/images/logo_mapcen.JPG")  

        # V√©rifier si l'image existe et est charg√©e
        if not pixmap.isNull():
            # Redimensionner l'image √† une taille raisonnable si n√©cessaire
            pixmap = pixmap.scaled(600, 400, Qt.KeepAspectRatio, Qt.SmoothTransformation)
            label_image.setPixmap(pixmap)
            label_image.setAlignment(Qt.AlignCenter)  # Centre l'image
        else:
            label_image.setText("Image introuvable")
            label_image.setAlignment(Qt.AlignCenter)

        # Ajouter le label avec l'image au layout
        layout.addWidget(label_image)

        # Cr√©er un QLabel pour afficher le changelog en HTML
        changelog_label = QLabel()
        changelog_label.setWordWrap(True)  # Permet le retour √† la ligne automatique

        try:
            # Charger le contenu du changelog depuis l'URL
            _, info_changelog = self.load_urls('config/yaml/links.yaml')
            fp = urllib.request.urlopen(info_changelog)
            mybytes = fp.read()
            html_changelog = mybytes.decode("utf8")
            fp.close()

            # Afficher le texte HTML dans le QLabel
            changelog_label.setText(html_changelog)
            changelog_label.setFont(QFont("Calibri", weight=QFont.Bold))

        except Exception as e:
            changelog_label.setText(f"Erreur lors du chargement du changelog : {e}")

        # Ajouter le QLabel au layout
        layout.addWidget(changelog_label)

        # Ajouter un bouton de fermeture
        button = QPushButton("Fermer")
        button.clicked.connect(dialog.accept)
        layout.addWidget(button)

        # Centrer le bouton
        layout.setAlignment(button, Qt.AlignCenter)

        # Appliquer le layout √† la fen√™tre
        dialog.setLayout(layout)

        # D√©finir la taille minimum du dialog pour s'adapter √† l'image et au texte
        dialog.setMinimumSize(620, 500)  # Ajuste la taille pour correspondre √† l'image, texte et bouton

        # Afficher la fen√™tre
        dialog.exec_()



    def is_first_run_of_new_version(self):
        """
        V√©rifie si c'est la premi√®re fois que cette version du plugin est d√©marr√©e en utilisant la version
        du plugin stock√©e dans 'metadata.txt' et la derni√®re version disponible en ligne.
        """
        settings = QSettings()

        # Obtenir la version actuelle du plugin depuis le fichier 'metadata.txt'
        metadonnees_plugin = open(self.plugin_path + '/metadata.txt')
        infos_metadonnees = metadonnees_plugin.readlines()
        version_utilisateur = infos_metadonnees[8].strip()  # Version actuelle du plugin (par exemple, '4.5.1')

        # Charger la derni√®re version depuis l'URL
        try:
            last_version_url, _ = self.load_urls('config/yaml/links.yaml')
            derniere_version = urllib.request.urlopen(last_version_url)
            num_last_version = derniere_version.readlines()[0].decode("utf-8").strip()  # R√©cup√©rer la derni√®re version disponible
        except Exception as e:
            self.iface.messageBar().pushMessage("Error", f"Failed to load URLs: {e}", level=Qgis.Critical, duration=5)
            return False

        # Obtenir la derni√®re version utilis√©e stock√©e dans les param√®tres
        last_version = settings.value("MapCEN/last_version", "", type=str)

        # Comparer la version actuelle avec la derni√®re version utilis√©e
        if last_version != version_utilisateur or version_utilisateur != num_last_version:
            # Si la version a chang√©, c'est un premier d√©marrage de cette version
            settings.setValue("MapCEN/last_version", version_utilisateur)  # Mettre √† jour la version stock√©e
            return True

        return False

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.
        We implement this ourselves since we do not inherit QObject.
        :param message: String for translation.
        :type message: str, QString
        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('MapCEN', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.
        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str
        :param text: Text that should be shown in menu items for this action.
        :type text: str
        :param callback: Function to be called when the action is triggered.
        :type callback: function
        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool
        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool
        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool
        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str
        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget
        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.
        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        # V√©rifier si c'est le premier d√©marrage de cette version
        if self.is_first_run_of_new_version():
            self.show_welcome_popup()

        icon_path = ':/plugins/map_cen/icons/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'MapCEN'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # Appeler la fonction pour informer l'utilisateur s'il a plus d'une configuration d'authentification
        self.check_authentication_configs()

        # will be set False in run()
        self.first_start = True


    def check_authentication_configs(self):
        """V√©rifie le nombre de configurations d'authentification disponibles et affiche un message si n√©cessaire."""

        managerAU = QgsApplication.authManager()
        auth_configs = managerAU.availableAuthMethodConfigs()  # R√©cup√©rer toutes les configurations disponibles

        # V√©rifier si une authentification par d√©faut a √©t√© d√©finie et l'appliquer
        settings = QSettings()
        default_auth_id = settings.value("MapCEN/default_auth_id", None)
        
        if default_auth_id:
            self.apply_authentication_if_needed(QgsDataSourceUri())  

        elif len(auth_configs) > 1:
            # Si plusieurs configurations sont disponibles et aucune par d√©faut n'est d√©finie
            QMessageBox.information(
                self.iface.mainWindow(),
                "Choix de la configuration d'authentification",
                "<center>Vous avez plusieurs configurations d'authentification disponibles.</center><br> Veuillez vous assurer de choisir la bonne configuration pour utiliser FluxCEN.<br>"
                "Vous pouvez d√©finir votre configuration par d√©fault en cliquant sur l'icone en forme de üõ†Ô∏è en bas √† droite de la fen√™tre du plugin."
            )

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&MapCEN'),
                action)
            self.iface.removeToolBarIcon(action)

    def function_from_plugin(self, event):
        print(self.my_map1.scale())


    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False

        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            pass

    def load_urls(self, yaml_file):
        # Charger le fichier YAML contenant plusieurs cl√©s
        config_path = os.path.join(self.plugin_path, yaml_file)
        
        # Lire le fichier YAML
        with open(config_path, 'r') as file:
            config = yaml.safe_load(file)
        
        # Extraire les URL pour chaque cl√©
        github_urls = config.get('github_urls', {})
        depot_plugins_url = config.get('depot_plugins_url', {})

        # Acc√©der aux sous-cl√©s sp√©cifiques
        info_changelog = github_urls.get('info_changelog')
        last_version_url = depot_plugins_url.get('last_version')

        return last_version_url, info_changelog
    
    def choose_default_authentication(self):
        managerAU = QgsApplication.authManager()
        auth_configs = managerAU.availableAuthMethodConfigs()  # R√©cup√©rer toutes les configurations disponibles

        if not auth_configs:
            QMessageBox.warning(self.dlg, "Pas de configurations", "Aucune configuration d'authentification disponible.")
            return

        dialog = AuthSelectionDialog(auth_configs)
        if dialog.exec_() == QDialog.Accepted:
            selected_auth_id = dialog.selected_auth_id
            # Enregistrer la configuration par d√©faut dans QSettings
            settings = QSettings()
            settings.setValue("MapCEN/default_auth_id", selected_auth_id)
            QMessageBox.information(self.dlg, "Configuration sauvegard√©e", "La configuration d'authentification par d√©faut a √©t√© d√©finie.")


    def apply_authentication_if_needed(self, uri):
        """
        Applique une configuration d'authentification si n√©cessaire.
        Charge automatiquement la configuration par d√©faut si elle est enregistr√©e dans QSettings.
        """
        settings = QSettings()
        default_auth_id = settings.value("MapCEN/default_auth_id", None)

        # Si une configuration par d√©faut existe, on l'applique automatiquement
        if default_auth_id:
            uri.setAuthConfigId(default_auth_id)
            return True

        # Si aucune configuration par d√©faut n'est d√©finie, ouvrir la bo√Æte de dialogue
        managerAU = QgsApplication.authManager()
        auth_configs = managerAU.availableAuthMethodConfigs()  # R√©cup√©rer toutes les configurations disponibles

        if len(auth_configs) == 1:
            # Si une seule configuration est disponible, on l'applique directement
            auth_id = list(auth_configs.keys())[0]
            uri.setAuthConfigId(auth_id)
            return True
        elif len(auth_configs) > 1:
            # Si plusieurs configurations sont disponibles, on invite l'utilisateur √† en choisir une
            dialog = AuthSelectionDialog(auth_configs)
            result = dialog.exec_()
            if result == QDialog.Accepted and dialog.selected_auth_id:
                uri.setAuthConfigId(dialog.selected_auth_id)
                return True
        else:
            QMessageBox.warning(iface.mainWindow(), "Attention", "Aucune configuration d'authentification n'a √©t√© trouv√©e dans votre QGIS. Veuillez ajouter la configuration d'authentification CEN-NA pour charger des couches n√©cessitant une authentification telles que la MFU.")
            

    def choix_dept(self):

        self.listes_sites_MFU_filtered = []

        departement = self.dlg.mComboBox_4.checkedItems()

        departements_selection = []

        for item in departement:
            departements_selection.append(item[0:2])

        expression_filtre = None  # initialize with a default value

        if len(self.dlg.mComboBox_4.checkedItems()) == 1:
            expression_filtre = 'substr("codesite",1,2) = %s' % str(departements_selection[0])
        if len(self.dlg.mComboBox_4.checkedItems()) >= 2 :
            expression_filtre = 'substr("codesite",1,2) IN %s' % str(tuple(departements_selection))
        if len(self.dlg.mComboBox_4.checkedItems()) > 3 :
            QMessageBox.question(iface.mainWindow(), u"Attention !",
                                 "Aucun site ne peut √™tre √† cheval sur plus de 3 d√©partements, veuillez limiter la s√©lection √† 3 sites !",
                                 QMessageBox.Ok)

        if self.dlg.mComboBox_4.currentIndex != -1:
            for p in self.sites_gere_centroid_layer.getFeatures(QgsFeatureRequest().setFilterExpression(expression_filtre)):

                codesite_index = p.fields().indexFromName('codesite')
                nom_site_index = p.fields().indexFromName('nom_site')

                if self.dlg.checkBox.isChecked():
                    self.listes_sites_MFU_filtered.append(str(p[codesite_index]))
                else:
                    self.listes_sites_MFU_filtered.append(str(p[nom_site_index]))

            print(self.sites_gere_centroid_layer.selectedFeatures())

        else:
            for p in self.sites_gere_centroid_layer.getFeatures():

                codesite_index = p.fields().indexFromName('codesite')
                nom_site_index = p.fields().indexFromName('nom_site')

                if self.dlg.checkBox.isChecked():
                    self.listes_sites_MFU_filtered.append(str(p[codesite_index]))
                else:
                    self.listes_sites_MFU_filtered.append(str(p[nom_site_index]))

            print(self.sites_gere_centroid_layer.selectedFeatures()[0])

        # print(self.dlg.mComboBox.checkedItems())
        # print(self.sites_gere_centroid_layer.selectedFeatures()[0])
        # print(self.sites_gere_centroid_layer.selectedFeatures()[0]["codesite"][:2])

        self.dlg.mComboBox.clear()

        self.listes_sites_MFU_filtered.sort()

        self.dlg.mComboBox.addItems(self.listes_sites_MFU_filtered)
    

    def initialisation(self):

        # Initialize the progress dialog
        progress_dialog = QProgressDialog("Chargement en cours...", "Annuler", 1, 7, self.dlg)
        progress_dialog.setWindowTitle("Initialisation")
        progress_dialog.setWindowModality(Qt.WindowModal)
        progress_dialog.setValue(1)
        
        # Step 1: Set initial radio button states
        self.dlg.radioButton.setChecked(True)
        self.dlg.radioButton.setEnabled(True)
        self.dlg.radioButton_2.setEnabled(True)
        self.dlg.radioButton_3.setEnabled(True)
        
        progress_dialog.setValue(2)
        if progress_dialog.wasCanceled():
            progress_dialog.close()
            return  # Exit if the user cancels

        # Step 2: Module initialization based on comboBox_3 selection
        if self.dlg.comboBox_3.currentText() == "P√©rim√®tres √©cologiques":
            self.module_perim_eco.initialisation()
        elif self.dlg.comboBox_3.currentText() == "Localisation de sites":
            self.module_loc_generale.initialisation()
        elif self.dlg.comboBox_3.currentText() == "Travaux":
            self.module_travaux.initialisation()
        else:
            self.dlg.mComboBox_3.hide()
            self.dlg.label_15.hide()

        progress_dialog.setValue(3)
        if progress_dialog.wasCanceled():
            progress_dialog.close()
            return

        # Step 3: Set up the URI and apply authentication
        uri = QgsDataSourceUri()
        uri.setParam("url", "https://opendata.cen-nouvelle-aquitaine.org/geoserver/fonciercen/wfs")
        uri.setParam("typename", "fonciercen:site_gere_point")
        if not self.apply_authentication_if_needed(uri):
            progress_dialog.close()
            return  # Exit if authentication fails
        
        progress_dialog.setValue(4)
        if progress_dialog.wasCanceled():
            progress_dialog.close()
            return

        # Step 4: Load the protected layer
        self.sites_gere_centroid_layer = QgsVectorLayer(uri.uri(), "Sites g√©r√©s CEN-NA", "WFS")
        if not self.sites_gere_centroid_layer.isValid():
            QMessageBox.warning(self.dlg, "Erreur de chargement", "Impossible de charger la couche 'Sites g√©r√©s CEN-NA'.")
            progress_dialog.close()
            return
        
        progress_dialog.setValue(5)
        if progress_dialog.wasCanceled():
            progress_dialog.close()
            return

        # Step 5: Populate lists for ComboBoxes
        self.listes_sites_MFU = []
        for p in self.sites_gere_centroid_layer.getFeatures():
            nom_site_index = p.fields().indexFromName('nom_site')
            self.listes_sites_MFU.append(str(p[nom_site_index]))
        self.dlg.mComboBox.addItems(self.listes_sites_MFU)
        
        progress_dialog.setValue(6)
        if progress_dialog.wasCanceled():
            progress_dialog.close()
            return

        # Step 6: Populate departments ComboBox
        self.dlg.mComboBox_4.clear()
        dpts_NA = ["16 - Charente", "17 - Charente-Maritime", "19 - Corr√®ze", "23 - Creuse", "24 - Dordogne",
                "33 - Gironde", "40 - Landes", "47 - Lot-et-Garonne", "64 - Pyr√©n√©es-Atlantique", "79 - Deux-S√®vres",
                "86 - Vienne", "87 - Haute-Vienne"]
        self.dlg.mComboBox_4.addItems(dpts_NA)
        
        progress_dialog.setValue(7)

        # Close the progress dialog when initialization is complete
        progress_dialog.close()

        
    def ajout_code_sites(self):

        # self.listes_sites_MFU.clear()
        # self.dlg.mComboBox.clear()

        if self.dlg.checkBox.isChecked():
            for p in self.sites_gere_centroid_layer.getFeatures():
                codesite_index = p.fields().indexFromName('codesite')
                self.listes_sites_MFU.append(str(p[codesite_index]))

        else:
            for p in self.sites_gere_centroid_layer.getFeatures():
                nom_site_index = p.fields().indexFromName('nom_site')
                self.listes_sites_MFU.append(str(p[nom_site_index]))

        self.dlg.mComboBox.addItems(self.listes_sites_MFU)

        self.choix_dept()

    def ajout_couches(self):

        self.dlg.commandLinkButton_4.setEnabled(True)

        ### -------------------- Chargement des sites fonciercen ---------------------- ###

        # Initialisation de `uri` ici avant de le passer √† `apply_authentication_if_needed`
        uri = QgsDataSourceUri()
        uri.setParam("url", "https://opendata.cen-nouvelle-aquitaine.org/geoserver/fonciercen/wfs")
        uri.setParam("typename", "fonciercen:mfu_cenna")

        # Appliquer l'authentification
        if not self.apply_authentication_if_needed(uri):
            return  # Abandonner si l'authentification √©choue

        # V√©rifier si les couches sont d√©j√† pr√©sentes
        couche_parcelles_existe = QgsProject.instance().mapLayersByName("Parcelles CEN NA en MFU")
        depts_existe = QgsProject.instance().mapLayersByName("D√©partement")

        if couche_parcelles_existe and depts_existe:
            # Si les deux couches sont d√©j√† charg√©es, on affiche un message et on quitte la fonction
            iface.messageBar().pushMessage("Couches d√©j√† charg√©es", "Les couches 'Parcelles CEN NA en MFU' et 'D√©partement' sont d√©j√† pr√©sentes dans le canevas QGIS.", level=Qgis.Success, duration=5)
            return

        # Chargement ou r√©cup√©ration de la couche 'Parcelles CEN NA en MFU'
        if couche_parcelles_existe:
            self.layer = couche_parcelles_existe[0]
            iface.messageBar().pushMessage("Couche 'Parcelles CEN NA en MFU'", "La couche 'Parcelles CEN NA en MFU' est d√©j√† charg√©e dans le canevas QGIS.", level=Qgis.Success, duration=5)
        else:
            self.layer = QgsVectorLayer(uri.uri(), "Parcelles CEN NA en MFU", "WFS")
            if not self.layer or not self.layer.isValid():
                QMessageBox.critical(iface.mainWindow(), "Erreur de chargement", "Impossible de charger la couche 'Parcelles CEN NA en MFU'. Veuillez contacter le p√¥le DSI !", QMessageBox.Ok)
                return
            QgsProject.instance().addMapLayer(self.layer)
            self.layer.loadNamedStyle(self.plugin_path + '/styles_couches/mfu_cenna.qml')
            self.layer.triggerRepaint()

        # Chargement ou r√©cup√©ration de la couche 'D√©partement'
        if depts_existe:
            self.depts_NA = depts_existe[0]
            iface.messageBar().pushMessage("Couche 'D√©partement'", "La couche 'D√©partement' est d√©j√† charg√©e dans le canevas QGIS.", level=Qgis.Success, duration=5)
        else:
            self.depts_NA = iface.addVectorLayer(
                "https://opendata.cen-nouvelle-aquitaine.org/administratif/wfs?VERSION=1.0.0&TYPENAME=administratif:departement&SRSNAME=EPSG:4326&request=GetFeature",
                "D√©partement", "WFS")
            if not self.depts_NA or not self.depts_NA.isValid():
                QMessageBox.critical(iface.mainWindow(), "Erreur de chargement", "Impossible de charger la couche 'D√©partement'. Veuillez contacter le p√¥le DSI !", QMessageBox.Ok)
                return

        # Chargement conditionnel du module 'P√©rim√®tres √©cologiques' en fonction de la s√©lection dans comboBox_3
        if self.dlg.comboBox_3.currentText() == "P√©rim√®tres √©cologiques":
            self.module_perim_eco.chargement_perim_eco()

        # Rafra√Æchir le canevas de la carte
        iface.mapCanvas().refresh()

    def onTextChanged(self, filter_text):

        filtered_sites_MFU = [item for item in self.listes_sites_MFU if item.lower().startswith(filter_text.lower())]

        checked_items = self.dlg.mComboBox.checkedItems()

        self.dlg.mComboBox.addItems(filtered_sites_MFU)

        # retain checked items
        for checked_item in checked_items:
            parent = parcelles_MFU.parent()
            parent.insertChildNode(1, myClone)
            parent.removeChildNode(parcelles_MFU)

        # On place la couche "Depts_NA" en premi√®re dans le gestionnaire des couches
        departements_NA = root.findLayer(self.depts_NA.id())
        if departements_NA:
            myClone = departements_NA.clone()
            parent = departements_NA.parent()
            parent.insertChildNode(0, myClone)
            parent.removeChildNode(departements_NA)
            
    def charger_fond_carte(self):
        """
        Charge le fond de carte appropri√© en fonction du bouton radio s√©lectionn√©
        et retourne la r√©f√©rence √† ce fond de carte.
        """
        fond_carte = None

        # Chargement du fond de carte en fonction du bouton radio s√©lectionn√©
        if self.dlg.radioButton.isChecked() == True:
            uri = "url=https://data.geopf.fr/wms-r/wms?SERVICE=WMS&VERSION=1.3.0&REQUEST=GetCapabilities&service=WMS&version=1.3.0&crs=EPSG:2154&format=image/png&layers=HR.ORTHOIMAGERY.ORTHOPHOTOS&styles"
            self.fond = QgsRasterLayer(uri, "BD Ortho IGN", 'wms')

            if not QgsProject.instance().mapLayersByName("BD Ortho IGN"):
                QgsProject.instance().addMapLayer(self.fond)
            else:
                print("Le fond de carte 'BD Ortho IGN' est d√©j√† charg√©")

            fond_carte = QgsProject.instance().mapLayersByName("BD Ortho IGN")[0]

        elif self.dlg.radioButton_2.isChecked() == True:
            tms = 'type=xyz&url=https://tile.openstreetmap.org/{z}/{x}/{y}.png&zmax=19&zmin=0'
            self.fond = QgsRasterLayer(tms, 'OSM', 'wms')

            if not QgsProject.instance().mapLayersByName("OSM"):
                QgsProject.instance().addMapLayer(self.fond)
            else:
                print("Le fond de carte OSM est d√©j√† charg√©")

            fond_carte = QgsProject.instance().mapLayersByName("OSM")[0]

        elif self.dlg.radioButton_3.isChecked() == True:
            uri = 'contextualWMSLegend=0&crs=EPSG:2154&dpiMode=7&featureCount=10&format=image/jpeg&http-header:apikey=ign_scan_ws&layers=SCAN25TOUR_PYR-JPEG_WLD_WM&styles&tilePixelRatio=0&url=https://data.geopf.fr/private/wms-r?VERSION%3D1.3.0'
            self.fond = QgsRasterLayer(uri, "SCAN25 IGN", "wms")

            if not QgsProject.instance().mapLayersByName("SCAN25 IGN"):
                QgsProject.instance().addMapLayer(self.fond)
            else:
                print("Le fond de carte SCAN25 IGN est d√©j√† charg√©")

            fond_carte = QgsProject.instance().mapLayersByName("SCAN25 IGN")[0]

        elif self.dlg.radioButton_4.isChecked() == True:
            uri = 'url=https://data.geopf.fr/wms-r/wms?SERVICE=WMS&VERSION=1.3.0&REQUEST=GetCapabilities&service=WMS&version=1.3.0&crs=EPSG:2154&format=image/png&layers=GEOGRAPHICALGRIDSYSTEMS.PLANIGNV2&styles'
            self.fond = QgsRasterLayer(uri, "Plan IGN", "wms")

            if not QgsProject.instance().mapLayersByName("Plan IGN"):
                QgsProject.instance().addMapLayer(self.fond)
            else:
                print("Le fond de carte 'Plan IGN' est d√©j√† charg√©")

            fond_carte = QgsProject.instance().mapLayersByName("Plan IGN")[0]
            
        return fond_carte
        
    def organiser_couches(self, fond_carte):
        """
        Organise les couches dans le gestionnaire de couches QGIS
        """
        if not fond_carte:
            return
            
        # Ordre des couches dans gestionnaires couches : fond de carte sous les autres couches
        root = QgsProject.instance().layerTreeRoot()
        fond_carte_node = root.findLayer(fond_carte.id())
        
        if fond_carte_node:
            myClone = fond_carte_node.clone()
            parent = fond_carte_node.parent()
            parent.insertChildNode(-1, myClone)
            parent.removeChildNode(fond_carte_node)

        # On place la couche "Parcelles MFU" en deuxi√®me dans le gestionnaire des couches
        parcelles_MFU = root.findLayer(self.layer.id())
        if parcelles_MFU:
            myClone = parcelles_MFU.clone()
            parent = parcelles_MFU.parent()
            parent.insertChildNode(1, myClone)
            parent.removeChildNode(parcelles_MFU)

        # On place la couche "Depts_NA" en premi√®re dans le gestionnaire des couches
        departements_NA = root.findLayer(self.depts_NA.id())
        if departements_NA:
            myClone = departements_NA.clone()
            parent = departements_NA.parent()
            parent.insertChildNode(0, myClone)
            parent.removeChildNode(departements_NA)
    
    def actualisation_emprise(self):
        """
        M√©thode principale pour actualiser l'emprise de la carte
        
        Returns:
            QgsRasterLayer: Le fond de carte charg√© ou None en cas d'erreur
        """
        self.dlg.pushButton_2.setEnabled(True)

        # V√©rifier la s√©lection de sites CEN uniquement si mComboBox est activ√©
        if self.dlg.mComboBox.isEnabled() and len(self.dlg.mComboBox.checkedItems()) < 1:
            QMessageBox.question(iface.mainWindow(), u"Attention !", "Veuillez s√©lectionner au moins un site CEN !", QMessageBox.Ok)
            return None

        # V√©rifier et charger la couche des sites CEN
        if QgsProject.instance().mapLayersByName("Sites g√©r√©s CEN-NA"):
            self.sites_gere_centroid_layer.removeSelection()
        else:
            QgsProject.instance().addMapLayer(self.sites_gere_centroid_layer)
        
        if not self.sites_gere_centroid_layer:
            QMessageBox.question(iface.mainWindow(), u"Erreur !",
                                "Impossible de charge la couche 'Sites g√©r√©s CEN-NA', veuillez contacter le p√¥le DSI !",
                                QMessageBox.Ok)
            return None

        # Charger le fond de carte appropri√©
        fond_carte = self.charger_fond_carte()
        

        self.organiser_couches(fond_carte)

        self.zoom_emprise_sites_selectionnes()
            
        return fond_carte
            
    def zoom_emprise_sites_selectionnes(self):
        """
        Zoom sur l'emprise des sites s√©lectionn√©s
        
        """
        self.layer.setSubsetString('')
        self.layer.removeSelection()
        # ### Zoom sur emprise du ou des sites CEN selectionn√©s:

        for sites in self.dlg.mComboBox.checkedItems():
            if self.dlg.checkBox.isChecked():
                self.sites_gere_centroid_layer.selectByExpression('"codesite"= \'{0}\''.format(sites.replace("'", "''")), QgsVectorLayer.AddToSelection)
                self.layer.selectByExpression('"codesite"= \'{0}\''.format(sites.replace("'", "''")), QgsVectorLayer.AddToSelection)

            else:
                self.sites_gere_centroid_layer.selectByExpression('"nom_site"= \'{0}\''.format(sites.replace("'", "''")), QgsVectorLayer.AddToSelection)
                self.layer.selectByExpression('"nom_site"= \'{0}\''.format(sites.replace("'", "''")), QgsVectorLayer.AddToSelection)

        iface.mapCanvas().zoomToSelected(self.layer)

        QgsProject.instance().setCrs(QgsCoordinateReferenceSystem.fromEpsgId(2154))


        self.pointage_sites_selectiones()


    def pointage_sites_selectiones(self):
        """
        Applique un style de pointage aux sites s√©lectionn√©s

        """

        rules = (
            ('Site CEN s√©lectionn√©', "is_selected()", 'red'),
        )

        # create a new rule-based renderer
        symbol = QgsSymbol.defaultSymbol(self.sites_gere_centroid_layer.geometryType())
        renderer = QgsRuleBasedRenderer(symbol)

        # get the "root" rule
        root_rule = renderer.rootRule()

        for label, expression, color_name in rules:
            # create a clone (i.e. a copy) of the default rule
            rule = root_rule.children()[0].clone()
            # set the label, expression and color
            rule.setLabel(label)
            rule.setFilterExpression(expression)
            symbol_layer = rule.symbol().symbolLayer(0)
            color = symbol_layer.color()
            generator = QgsGeometryGeneratorSymbolLayer.create({})
            generator.setSymbolType(QgsSymbol.Marker)
            generator.setGeometryExpression("centroid($geometry)")
            generator.setColor(QColor('Red'))
            rule.symbol().setColor(QColor(color_name))
            # set the scale limits if they have been specified
            # append the rule to the list of rules
            rule.symbol().changeSymbolLayer(0, generator)
            root_rule.appendChild(rule)

        # delete the default rule
        root_rule.removeChildAt(0)

        # apply the renderer to the layer
        self.sites_gere_centroid_layer.setRenderer(renderer)
        # refresh the layer on the map canvas
        self.sites_gere_centroid_layer.triggerRepaint()

        self.choix_type_mise_en_page()
        

    def choix_type_mise_en_page(self):

        # Appeler la mise en page appropri√©e selon le module actif
        if self.dlg.comboBox_3.currentText() == "Travaux":
            self.module_travaux.choix_mise_en_page()
        elif self.dlg.comboBox_3.currentText() == "P√©rim√®tres √©cologiques":
            self.module_perim_eco.mise_en_page()
        elif self.dlg.comboBox_3.currentText() == "Localisation de sites":
            self.module_loc_generale.mise_en_page()
        else:
            self.mise_en_page()


    def masquer_parcelles_voisines(self):

        selected_sites = [site.replace("'", "''") for site in self.dlg.mComboBox.checkedItems()]

        if selected_sites:
            # Filtrer par code ou nom de site selon l'√©tat de la checkBox
            if self.dlg.checkBox.isChecked():
                filter_expression = '"codesite" IN ({0})'.format(", ".join(f"'{site}'" for site in selected_sites))
            else:
                filter_expression = '"nom_site" IN ({0})'.format(", ".join(f"'{site}'" for site in selected_sites))

            # Appliquer le filtre sur la couche
            self.layer.setSubsetString(filter_expression)
        else:
            QMessageBox.information(iface.mainWindow(), "Aucun site s√©lectionn√©", "Veuillez s√©lectionner au moins un site CEN pour appliquer le filtre.", QMessageBox.Ok)

        # Rafra√Æchir la carte pour afficher uniquement les parcelles s√©lectionn√©es
        iface.mapCanvas().refresh()
        self.mise_en_page()


    def mise_en_page(self):

        myRenderer = self.depts_NA.renderer()

        if self.depts_NA.geometryType() == QgsWkbTypes.PolygonGeometry:
            mySymbol1 = QgsSymbol.defaultSymbol(self.depts_NA.geometryType())
            fill_layer = QgsSimpleFillSymbolLayer.create(
                {'color': '255,255,255,255', 'outline_color': '0,0,0,255', 'outline_width': '0.1'}
            )
            mySymbol1.changeSymbolLayer(0, fill_layer)
            myRenderer.setSymbol(mySymbol1)

        self.depts_NA.triggerRepaint()

        self.dlg.horizontalSlider.setValue(0)

        # ajout de la date, l'auteur, source etc...
        date_du_jour = date.today().strftime("%d/%m/%Y")

        # QgsProject.instance().layerTreeRoot().findLayer(self.sites_gere_centroid_layer.id()).setItemVisibilityChecked(False)

        ## Ajout de la mise en page au composeur de carte:

        project = QgsProject.instance()
        self.manager = project.layoutManager()
        layout_name = 'Mise en page automatique MapCEN (MFU)'
        layouts_list = self.manager.printLayouts()
        # Just 4 debug
        # remove any duplicate layouts
        for self.layout in layouts_list:
            if self.layout.name() == layout_name:
                self.manager.removeLayout(self.layout)
            #     reply = QMessageBox.question(None, (u'Delete layout...'),
            #                                  (
            #                                      u"There's already a layout named '%s'\nDo you want to delete it?")
            #                                  % layout_name,
            #                                  QMessageBox.Yes | QMessageBox.No, QMessageBox.No)
            #     if reply == QMessageBox.No:
            #         return
            #     else:
            #         manager.removeLayout(layout)
            #         print((u"Previous layout names '%s' removed... ") % layout_name)

        self.layout = QgsPrintLayout(project)
        self.layout.initializeDefaults()
        # manager.addLayout(layout)
        self.layout.setName(layout_name)


        ## Add map to layout
        self.my_map1 = QgsLayoutItemMap(self.layout)

        # Charger une carte vide
        self.my_map1.setRect(20, 20, 20, 20)


        self.my_map1.setLayers([self.layer, self.fond])


        # Mettre le canvas courant comme emprise
        self.my_map1.setExtent(iface.mapCanvas().extent())

        # Position de la carte dans le composeur
        self.my_map1.attemptMove(QgsLayoutPoint(5, 23, QgsUnitTypes.LayoutMillimeters))

        #on dimensionne le rendu de la carte (pour r√©f√©rence la page totale est une page A4 donc 297*210)
        self.my_map1.attemptResize(QgsLayoutSize(185, 182, QgsUnitTypes.LayoutMillimeters))
        self.my_map1.refresh()

        self.my_map1.setBackgroundColor(QColor(255, 255, 255, 255))
        self.my_map1.setFrameEnabled(True)
        self.layout.addLayoutItem(self.my_map1)

        self.my_map1.setId("carte_principale_MFU")
        # print(self.my_map1.id())

        # --- create map item 2 (shapefile, raster 2, basemap)

        my_map2 = QgsLayoutItemMap(self.layout)
        my_map2.setRect(20, 20, 20, 20)
        my_map2.setPos(213, 28)
        my_map2.setFrameEnabled(False)

        my_map2.setLayers([self.sites_gere_centroid_layer, self.depts_NA])

        ## Ajustement de l'emprise de la couche depts_CEN-NA au CRS 2154 :

        crsSrc = QgsCoordinateReferenceSystem("EPSG:4326")

        # recherche du CRS du projet pour r√©aliser transformation (normalement 2154):
        crsDest = QgsCoordinateReferenceSystem(QgsCoordinateReferenceSystem("EPSG:2154"))
        transformContext = QgsProject.instance().transformContext()
        xform = QgsCoordinateTransform(crsSrc, crsDest, transformContext)

        # forward transformation: src -> dest
        extent = xform.transform(self.depts_NA.extent())

        my_map2.setExtent(extent)
        my_map2.setScale(30000000)

        my_map2.attemptMove(QgsLayoutPoint(213, 28, QgsUnitTypes.LayoutMillimeters))
        my_map2.attemptResize(QgsLayoutSize(63, 63, QgsUnitTypes.LayoutMillimeters))

        my_map2.refresh()

        self.layout.addLayoutItem(my_map2)


        ## Ajout de la legende :
        legend = QgsLayoutItemLegend(self.layout)
        # legend.setTitle('Legende')
        legend.adjustBoxSize()
        legend.setFrameEnabled(False)
        legend.setAutoUpdateModel(False)

        root = QgsLayerTree()
        # root.addLayer(self.layer).setUseLayerName(False)
        # root.addLayer(self.layer).setName("Types de ma√Ætrise")

        legend.updateLegend()

        legend.setLegendFilterByMapEnabled(True)
        self.layout.addItem(legend)
        legend.setLinkedMap(self.my_map1)

        layer_to_remove = self.fond
        legend.model().rootGroup().removeLayer(layer_to_remove)

        legend.attemptMove(QgsLayoutPoint(200, 99, QgsUnitTypes.LayoutMillimeters))

        # legend.setColumnCount(3)

        legend.setColumnCount(0)
        legend.setEqualColumnWidth(True)
        legend.setSplitLayer(True)


        legend.setWrapString("*")

        legend.adjustBoxSize()

        self.layout.refresh()



        ## Ajout d'un titre √† la mise en page
        title = QgsLayoutItemLabel(self.layout)
        self.layout.addLayoutItem(title)

        #lorsque sites de plusieurs d√©partements s√©lectionn√©s, on les stockes dans une liste pour afficher les n¬∞ d√©partements dans le titre:
        code_dpt = []
        for i in self.sites_gere_centroid_layer.selectedFeatures():
            code_dpt.append(i["codesite"][:2])

        if len(self.dlg.mComboBox_4.checkedItems()) > 1:
            titre = str(', '.join(self.dlg.mComboBox.checkedItems()) + " " + str(tuple([int(x) for x in code_dpt])) )
        else:
            titre = str(', '.join(self.dlg.mComboBox.checkedItems()) + " (" + self.sites_gere_centroid_layer.selectedFeatures()[0]["codesite"][:2] + ")")

        title.setText(titre)
        title.setFont(QFont("Calibri", 16, QFont.Bold))
        title.attemptMove(QgsLayoutPoint(4.2, 5.8, QgsUnitTypes.LayoutMillimeters))
        title.adjustSizeToText()
        self.layout.addItem(title)


        ## Ajout d'un sous-titre √† la mise en page
        subtitle = QgsLayoutItemLabel(self.layout)
        self.layout.addLayoutItem(subtitle)
        titre = str("Ma√Ætrise fonci√®re ou d'usage au " + date_du_jour)
        subtitle.setText(titre)
        subtitle.setFont(QFont("Calibri", 14))
        subtitle.attemptMove(QgsLayoutPoint(10.5, 13.5, QgsUnitTypes.LayoutMillimeters))
        subtitle.adjustSizeToText()
        self.layout.addItem(subtitle)


        ## Ajout du logo CEN NA en haut √† gauche de la page
        layoutItemPicture = QgsLayoutItemPicture(self.layout)
        layoutItemPicture.setResizeMode(QgsLayoutItemPicture.Zoom)
        layoutItemPicture.setMode(QgsLayoutItemPicture.FormatRaster)
        layoutItemPicture.setPicturePath(self.plugin_path + '/logo.jpg')


        # dim_image_original = [250, 84]
        # new_dim = [i * 0.15 for i in dim_image_original]
        layoutItemPicture.attemptMove(QgsLayoutPoint(218, 5, QgsUnitTypes.LayoutMillimeters))
        layoutItemPicture.attemptResize(QgsLayoutSize(720,249, QgsUnitTypes.LayoutPixels))

        self.layout.addLayoutItem(layoutItemPicture)


        ## Ajout de l'√©chelle √† la mise en page
        self.scalebar = QgsLayoutItemScaleBar(self.layout)
        self.scalebar.setStyle('Single Box')
        self.scalebar.setLinkedMap(self.my_map1)
        self.scalebar.applyDefaultSize()
        self.scalebar.applyDefaultSettings()

        self.scalebar.setNumberOfSegments(2)
        self.scalebar.setNumberOfSegmentsLeft(0)

        self.layout.addLayoutItem(self.scalebar)
        self.scalebar.attemptMove(QgsLayoutPoint(222,178, QgsUnitTypes.LayoutMillimeters))
        self.scalebar.setFixedSize(QgsLayoutSize(50, 15))


        # ajout de la fleche du Nord
        north = QgsLayoutItemPicture(self.layout)
        north.setPicturePath(self.plugin_path + "/NorthArrow_02.svg")
        self.layout.addLayoutItem(north)
        north.attemptResize(QgsLayoutSize(8.4, 12.5, QgsUnitTypes.LayoutMillimeters))
        north.attemptMove(QgsLayoutPoint(205,178, QgsUnitTypes.LayoutMillimeters))



        info = ["R√©alisation : " + "DSI / CEN Nouvelle-Aquitaine (" + date_du_jour + ")"]
        credit_text = QgsLayoutItemLabel(self.layout)
        credit_text.setText(info[0])
        credit_text.setFont(QFont("Calibri", 11))
        self.layout.addLayoutItem(credit_text)
        credit_text.attemptMove(QgsLayoutPoint(200, 200, QgsUnitTypes.LayoutMillimeters))
        credit_text.adjustSizeToText()
        # credit_text.attemptResize(QgsLayoutSize(95, 5, QgsUnitTypes.LayoutMillimeters))


        info2 = ["Source: IGN (fond de carte), IGN (Admin Express), cadastre ETALAB, FoncierCEN"]
        credit_text2 = QgsLayoutItemLabel(self.layout)
        credit_text2.setText(info2[0])
        credit_text2.setFont(QFont("Calibri", 9))
        credit_text2.setItemRotation(-90)
        self.layout.addLayoutItem(credit_text2)
        credit_text2.attemptMove(QgsLayoutPoint(191, 204, QgsUnitTypes.LayoutMillimeters))
        credit_text2.adjustSizeToText()
        # credit_text2.attemptResize(QgsLayoutSize(150, 4, QgsUnitTypes.LayoutMillimeters))

        temp_layer = self.sites_gere_centroid_layer.materialize(QgsFeatureRequest().setFilterFids(self.sites_gere_centroid_layer.selectedFeatureIds()))

        surf_parcelles_site_selectionne = temp_layer.aggregate(QgsAggregateCalculator.Sum, "contenance_mfu_m2")
        surf_ha = round(surf_parcelles_site_selectionne[0] / 10000, 2)
        info3 = "Surface totale ma√Ætris√©e sur le site : " + str(surf_ha) + " ha."
        credit_text3 = QgsLayoutItemLabel(self.layout)
        credit_text3.setText(info3)
        credit_text3.setFont(QFont("Calibri", 12, italic=True))
        self.layout.addLayoutItem(credit_text3)
        credit_text3.attemptMove(QgsLayoutPoint(205, 92, QgsUnitTypes.LayoutMillimeters))
        credit_text3.adjustSizeToText()
        # credit_text3.attemptResize(QgsLayoutSize(90, 8, QgsUnitTypes.LayoutMillimeters))


        # Finally add layout to the project via its manager
        self.manager.addLayout(self.layout)

        self.zoom_to_layer()

        self.echelle = self.my_map1.scale()

        self.bar_echelle_auto(self.my_map1,  self.scalebar)


    def ouverture_composeur(self):

        ###  -------------------- Automatisation de la mise en page ----------------------- ###
        if self.dlg.comboBox_3.currentText() == "P√©rim√®tres √©cologiques":
            iface.openLayoutDesigner(self.module_perim_eco.layout_carto_perim_eco)
        elif self.dlg.comboBox_3.currentText() == "Localisation de sites":
            iface.openLayoutDesigner(self.module_loc_generale.layout_carto_generale)
        elif self.dlg.comboBox_3.currentText() == "Travaux":
            iface.openLayoutDesigner(self.module_travaux.layout_carto_travaux)
        else:
            iface.openLayoutDesigner(self.layout)

        #### Pour ajouter deuxieme carte au composer d'impression:
        ##https://gis.stackexchange.com/questions/331723/display-two-different-maps-with-different-layers-in-one-layout-in-pyqgis-proble


    def zoom_to_layer(self):

        self.layout2 = QgsProject.instance().layoutManager().layoutByName('Mise en page automatique MapCEN (MFU)').clone()
        self.dlg.graphicsView.setScene(self.layout2)


    def export(self, options_instance=None):
        # V√©rifie si la fonction est appel√©e depuis OptionsWindow
        if options_instance and hasattr(options_instance, 'a'):
            # Utiliser la r√©solution d√©finie dans OptionsWindow
            resolution_dpi = options_instance.a
            # Demander √† l'utilisateur o√π enregistrer l'image
            fileName = QFileDialog.getSaveFileName(None, 'Sauvegarder en jpg', '', filter='*.jpg')
            if not fileName or not fileName[0]:
                return  # L'utilisateur a annul√©
        else:
            # Si appel√© directement, ouvrir la fen√™tre d'options
            options_window = OptionsWindow()
            options_window.show()
            # La fonction sera rappel√©e via set_resolution avec la r√©solution choisie
            return
            
        dossier_sauvegarde = fileName[0]

        ###  -------------------- Automatisation de la mise en page ----------------------- ###
        # D√©terminer la mise en page √† utiliser
        try:
            if self.dlg.comboBox_3.currentText() == "P√©rim√®tres √©cologiques":
                layout = QgsProject.instance().layoutManager().layoutByName('Mise en page automatique MapCEN (P√©rim√®tres √©cologiques)')
            elif self.dlg.comboBox_3.currentText() == "Localisation de sites":
                layout = QgsProject.instance().layoutManager().layoutByName('Mise en page automatique MapCEN (Carto de localisation g√©n√©rale)')
            elif self.dlg.comboBox_3.currentText() == "Travaux":
                layout = QgsProject.instance().layoutManager().layoutByName('Mise en page automatique MapCEN (Travaux)')
            else:
                layout = QgsProject.instance().layoutManager().layoutByName('Mise en page automatique MapCEN (MFU)')
        except:
            # Si on est appel√© depuis OptionsWindow, self.dlg n'existe peut-√™tre pas
            layout = QgsProject.instance().layoutManager().layoutByName('Mise en page automatique MapCEN (MFU)')
        
        if not layout:
            QMessageBox.warning(None, "Erreur", "La mise en page n'a pas pu √™tre trouv√©e. Veuillez v√©rifier sa disponibilit√© dans le gestionnaire de mises en page.")
            return

        # Configurer la r√©solution d'export
        exporter = QgsLayoutExporter(layout)
        settings = QgsLayoutExporter.ImageExportSettings()
        settings.dpi = resolution_dpi
        
        # Exporter l'image
        result_img = exporter.exportToImage(dossier_sauvegarde, settings)
        
        # Afficher le r√©sultat
        if result_img == QgsLayoutExporter.Success:
            QMessageBox.information(None, "Export r√©ussi", f"La carte a √©t√© export√©e avec succ√®s en {resolution_dpi} DPI.")
        else:
            QMessageBox.critical(None, "Erreur d'export", "L'export a √©chou√©. Veuillez v√©rifier le chemin d'enregistrement et r√©essayer.")
            
        print(f"R√©sultat de l'export: {result_img}")  # 0 = export r√©ussi !

    def liste_couche_template(self):


        if self.dlg.comboBox.currentText() == "1. Mod√®le carto standard (consolid√©).qpt":
            self.dlg.lineEdit_4.setEnabled(True)
            self.dlg.mComboBox_2.setEnabled(True)
        else:
            self.dlg.lineEdit_4.setEnabled(False)
            self.dlg.mComboBox_2.setEnabled(False)



        self.dlg.mComboBox_2.clear()

        couches = []

        for lyr in QgsProject.instance().mapLayers().values():
            couches.append(lyr.name())

        self.dlg.mComboBox_2.addItems(sorted(couches))



    def chargement_qpt(self):


        project = QgsProject.instance()
        self.manager = project.layoutManager()
        layout_name = self.dlg.comboBox.currentText()
        layouts_list = self.manager.printLayouts()

        for i in layouts_list:
            if i.name() == layout_name:
                self.manager.removeLayout(i)

        if self.dlg.comboBox.currentText() == " ":
            QMessageBox.question(iface.mainWindow(), u"Aucun template s√©lectionn√© !", "Veuillez s√©lectionner un mod√®le !", QMessageBox.Ok)

        else:

            for filename in glob.glob(self.plugin_path + "/mises_en_pages/*.qpt"):
                with open(os.path.join(os.getcwd(), filename), 'r') as f:
                    self.layout = QgsPrintLayout(project)
                    self.layout.initializeDefaults()
                    template_content = f.read()
                    doc = QDomDocument()
                    doc.setContent(template_content)
                    self.layout.loadFromTemplate(doc, QgsReadWriteContext(), True)
                    self.layout.setName(os.path.basename(filename))


                    if self.layout.name() == "1. Mod√®le carto standard (consolid√©).qpt":

                        self.actualisation_mise_en_page()

                        ## Add map to layout
                        self.map_modele_test = QgsLayoutItemMap(self.layout)
                        # Charger une carte vide
                        self.map_modele_test.setRect(20, 20, 20, 20)
                        # Mettre le canvas courant comme emprise
                        self.map_modele_test.setExtent(iface.mapCanvas().extent())
                        # Position de la carte dans le composeur

                        self.map_modele_test.attemptMove(self.template_parameters['map_position'])
                        # on dimensionne le rendu de la carte (pour r√©f√©rence la page totale est une page A4 donc 297*210)
                        self.map_modele_test.attemptResize(self.template_parameters['map_size'])

                        self.map_modele_test.refresh()

                        self.map_modele_test.setBackgroundColor(QColor(255, 255, 255, 255))
                        self.map_modele_test.setFrameEnabled(True)
                        self.layout.addLayoutItem(self.map_modele_test)
                        self.map_modele_test.setId("carte_principale")

                        ## Ajout d'un titre √† la mise en page
                        title = QgsLayoutItemLabel(self.layout)
                        self.layout.addLayoutItem(title)
                        titre = self.dlg.lineEdit_2.text()
                        title.setText(titre)
                        title.setFont(QFont("Calibri", 15, QFont.Bold))
                        title.attemptMove(self.template_parameters['title_position'])
                        title.attemptResize(self.template_parameters['title_size'])
                        self.layout.addItem(title)
                        # title.adjustSizeToText() on n'utilise plutot setFixedSize pour pouvoir centrer le titre de mani√®re plus optimale ici
                        title.setHAlign(Qt.AlignHCenter)
                        title.setVAlign(Qt.AlignVCenter)


                        ## Ajout d'un sous titre √† la mise en page
                        subtitle = QgsLayoutItemLabel(self.layout)
                        self.layout.addLayoutItem(subtitle)
                        titre = self.dlg.lineEdit_3.text()
                        subtitle.setText(titre)
                        subtitle.setFont(QFont("MS Shell Dlg 2", 10))
                        subtitle.attemptMove(self.template_parameters['subtitle_position'])
                        subtitle.attemptResize(self.template_parameters['subtitle_size'])
                        self.layout.addItem(subtitle)
                        subtitle.setHAlign(Qt.AlignHCenter)
                        subtitle.setVAlign(Qt.AlignVCenter)


                        ## Ajout du logo CEN NA en haut √† gauche de la page
                        logo = QgsLayoutItemPicture(self.layout)
                        logo.setResizeMode(QgsLayoutItemPicture.Zoom)
                        logo.setMode(QgsLayoutItemPicture.FormatRaster)
                        logo.attemptMove(self.template_parameters['logo_position'])
                        logo.setFixedSize(self.template_parameters['logo_size'])
                        logo.setPicturePath(self.plugin_path + '/logo.jpg')
                        self.layout.addLayoutItem(logo)


                        ## Ajout de la legende :
                        legend = QgsLayoutItemLegend(self.layout)

                        legend.setId('legende_model1')
                        # legend.setTitle('Legende')
                        legend.adjustBoxSize()
                        legend.setFrameEnabled(False)
                        legend.setAutoUpdateModel(False)

                        legend.setLinkedMap(self.map_modele_test)
                        self.layout.addItem(legend)

                        # group_name = 'P√©rim√®tres √©cologiques'  # Name of a group in your legend

                        checked_items = self.dlg.mComboBox_2.checkedItems()

                        layers_to_remove = []

                        for lyr in project.mapLayers().values():
                            if lyr.name() not in checked_items:
                                layers_to_remove.append(lyr.name())

                        # the layer tree
                        root = project.layerTreeRoot()

                        # get legend
                        legend = [i for i in self.layout.items() if isinstance(i, QgsLayoutItemLegend)][0]

                        # disable auto-update
                        legend.setAutoUpdateModel(False)
                        legend.setLegendFilterByMapEnabled(True)
                        # legend model
                        model = legend.model()

                        # the root legend group
                        root_group = model.rootGroup()

                        # loop through layer names
                        for layer_name in layers_to_remove:
                            # find layer in project
                            layer = project.mapLayersByName(layer_name)[0]
                            # get layer tree layer instance of layer
                            layertreelayer = root.findLayer(layer.id())

                            # get the parent of the layer tree layer (layer tree root, or group)
                            parent = layertreelayer.parent()

                            # if the parent is a group and has a name, find it and remove the layer
                            if isinstance(parent, QgsLayerTreeGroup) and parent.name():
                                group = root_group.findGroup(parent.name())
                                group.removeLayer(layer)
                            # remove layers that are not in a group
                            else:
                                root_group.removeLayer(layer)


                        legend.setEqualColumnWidth(True)
                        legend.setSplitLayer(True)
                        legend.setColumnSpace(5)
                        legend.rstyle(QgsLegendStyle.Title).setMargin(1.5)  # 1 mm
                        legend.rstyle(QgsLegendStyle.Group).setMargin(QgsLegendStyle.Top, 3)
                        legend.rstyle(QgsLegendStyle.Subgroup).setMargin(QgsLegendStyle.Top, 3)

                        legend.adjustBoxSize()
                        self.layout.refresh()

                        legend.updateLegend()
                        legend.attemptMove(self.template_parameters['legend_position'])


                        ## Ajout de l'√©chelle √† la mise en page
                        self.scalebar_qpt = QgsLayoutItemScaleBar(self.layout)
                        self.scalebar_qpt.setStyle('Single Box')
                        self.scalebar_qpt.setLinkedMap(self.map_modele_test)
                        self.scalebar_qpt.applyDefaultSize()
                        self.scalebar_qpt.applyDefaultSettings()

                        self.scalebar_qpt.setNumberOfSegments(2)
                        self.scalebar_qpt.setNumberOfSegmentsLeft(0)

                        self.scalebar_qpt.attemptMove(self.template_parameters['scalebar_position'])
                        self.scalebar_qpt.attemptResize(self.template_parameters['scalebar_size'])


                        self.layout.addLayoutItem(self.scalebar_qpt)
                        # self.scalebar_qpt.setFixedSize(QgsLayoutSize(55, 15))

                        # ajout de la fleche du Nord
                        north = QgsLayoutItemPicture(self.layout)
                        north.setPicturePath(self.plugin_path + "/NorthArrow_02.svg")
                        self.layout.addLayoutItem(north)
                        north.attemptMove(self.template_parameters['north_position'])
                        north.attemptResize(self.template_parameters['north_size'])

                        # ajout note info:
                        info = ["R√©alisation : " + "DSI / CEN Nouvelle-Aquitaine (" + date.today().strftime(
                            "%d/%m/%Y") + ")"]
                        info2 = ["Source : " + self.dlg.lineEdit_4.text()]
                        credit_text = QgsLayoutItemLabel(self.layout)
                        credit_text.setText(info[0])
                        credit_text.setFont(QFont("Calibri", 9))
                        credit_text.setHAlign(Qt.AlignRight)
                        credit_text.setVAlign(Qt.AlignVCenter)
                        credit_text.setItemRotation(-90)
                        credit_text2 = QgsLayoutItemLabel(self.layout)
                        credit_text2.setText(info2[0])
                        credit_text2.setFont(QFont("Calibri", 9))
                        credit_text2.setHAlign(Qt.AlignRight)
                        credit_text2.setVAlign(Qt.AlignVCenter)
                        credit_text.attemptMove(self.template_parameters['credit_text_position'])
                        credit_text.attemptResize(self.template_parameters['credit_text_size'])
                        credit_text2.attemptMove(self.template_parameters['credit_text2_position'])
                        credit_text2.attemptResize(self.template_parameters['credit_text2_size'])
                        self.layout.addLayoutItem(credit_text)
                        self.layout.addLayoutItem(credit_text2)

                        # credit_text.attemptResize(QgsLayoutSize(95, 5, QgsUnitTypes.LayoutMillimeters))

                    self.bar_echelle_auto(iface.mapCanvas(), self.scalebar_qpt)

                    existing_layout = project.layoutManager().layoutByName(self.layout.name())
                    if existing_layout:
                        project.layoutManager().removeLayout(existing_layout)

                    result = project.layoutManager().addLayout(self.layout)
                    print(result)



                    self.manager.addLayout(self.layout)


            fichier_mise_en_page = self.dlg.comboBox.currentText()

            layout_modifie = QgsProject.instance().layoutManager().layoutByName(fichier_mise_en_page)

            # map_item = layout_modifie.itemById("carte_principale")
            # # map_item = layout_modifie.referenceMap()
            #
            # map_item.zoomToExtent(iface.mapCanvas().extent())
            #
            iface.openLayoutDesigner(layout_modifie)


    def actualisation_mise_en_page(self):
        # Param√®tres pour chaque combinaison de taille de page et d'orientation
        page_settings = {
            ('A4', 'Portrait'): {
                'map_size': (199, 175), 'map_position': (5, 25),
                'title_size': (200, 8), 'title_position': (5, 2),
                'subtitle_size': (200, 8), 'subtitle_position': (5, 12),
                'logo_size': (46, 16), 'logo_position': (5, 4),
                'legend_size': (405, 203), 'legend_position': (5, 205),
                'scalebar_size': (55, 15), 'scalebar_position': (145, 215),
                'north_size': (12, 12), 'north_position': (193, 214),
                'credit_text_size': (100, 3.9), 'credit_text_position': (205, 125),
                'credit_text2_size': (100, 3.9), 'credit_text2_position': (104, 201)
            },
            ('A4', 'Landscape'): {
                'map_size': (285, 145), 'map_position': (6, 23),
                'title_size': (286, 8), 'title_position': (5, 2),
                'subtitle_size': (286, 8), 'subtitle_position': (5, 10),
                'logo_size': (46, 16), 'logo_position': (5, 4),
                'legend_size': (405, 203), 'legend_position': (5, 168),
                'scalebar_size': (55, 15), 'scalebar_position': (207, 183),
                'north_size': (8.4, 12.5), 'north_position': (273, 182),
                'credit_text_size': (100, 3.9), 'credit_text_position': (291.5, 123),
                'credit_text2_size': (100, 3.9), 'credit_text2_position': (189, 168.5)
            },
            ('A3', 'Portrait'): {
                'map_size': (285, 260), 'map_position': (6, 23),
                'title_size': (286, 8), 'title_position': (5, 2),
                'subtitle_size': (286, 8), 'subtitle_position': (5, 10),
                'logo_size': (46, 16), 'logo_position': (5, 4),
                'legend_size': (405, 203), 'legend_position': (5, 284),
                'scalebar_size': (50, 15), 'scalebar_position': (207, 298),
                'north_size': (8.4, 12.5), 'north_position': (273, 297),
                'credit_text_size': (100, 3.9), 'credit_text_position': (291.5, 123),
                'credit_text2_size': (100, 3.9), 'credit_text2_position': (189, 284)
            },
            ('A3', 'Landscape'): {
                'map_size': (408.5, 222), 'map_position': (5, 23.5),
                'title_size': (409, 8), 'title_position': (5, 2),
                'subtitle_size': (409, 8), 'subtitle_position': (5, 10),
                'logo_size': (46, 16), 'logo_position': (5, 4),
                'legend_size': (405, 203), 'legend_position': (5, 249),
                'scalebar_size': (55, 15), 'scalebar_position': (323, 270),
                'north_size': (8.4, 12.5), 'north_position': (402, 270),
                'credit_text_size': (100, 3.9), 'credit_text_position': (415, 123),
                'credit_text2_size': (100, 3.9), 'credit_text2_position': (313, 247)
            }
        }

        # D√©termine la taille et l'orientation de la page s√©lectionn√©e
        page_size = 'A4' if self.dlg.radioButton_6.isChecked() else 'A3'
        orientation = 'Portrait' if self.dlg.radioButton_7.isChecked() else 'Landscape'
        
        # Applique les param√®tres du dictionnaire
        pc = self.layout.pageCollection()
        pc.pages()[0].setPageSize(page_size, getattr(QgsLayoutItemPage, orientation))

        settings = page_settings[(page_size, orientation)]
        for param, (width, height) in settings.items():
            if 'size' in param:
                self.template_parameters[param] = QgsLayoutSize(width, height, QgsUnitTypes.LayoutMillimeters)
            else:
                self.template_parameters[param] = QgsLayoutPoint(width, height, QgsUnitTypes.LayoutMillimeters)



    def niveau_zoom(self):

        if self.dlg.horizontalSlider.value() == 2:
            self.my_map1.setScale(self.echelle/1.8)
        elif self.dlg.horizontalSlider.value() == 1:
            self.my_map1.setScale(self.echelle/1.4)
        elif self.dlg.horizontalSlider.value() == 0:
            self.my_map1.setScale(self.echelle)
        elif self.dlg.horizontalSlider.value() == -1:
            self.my_map1.setScale(self.echelle*1.4)
        else:
            self.my_map1.setScale(self.echelle*1.8)

        self.my_map1.refresh()

        self.layout3 = QgsProject.instance().layoutManager().layoutByName('Mise en page automatique MapCEN (MFU)').clone()
        self.dlg.graphicsView.setScene(self.layout3)
        self.layout.refresh()

        self.bar_echelle_auto(self.my_map1, self.scalebar)


    def bar_echelle_auto(self, echelle, bar_echelle):

        if echelle.scale() >= 45000:
            bar_echelle.setUnits(QgsUnitTypes.DistanceKilometers)
            bar_echelle.setUnitLabel("km")
            bar_echelle.setUnitsPerSegment(1.5)

        elif echelle.scale() >= 30000:
            bar_echelle.setUnits(QgsUnitTypes.DistanceKilometers)
            bar_echelle.setUnitLabel("km")
            bar_echelle.setUnitsPerSegment(1)

        elif echelle.scale() >= 20000:
            bar_echelle.setUnits(QgsUnitTypes.DistanceKilometers)
            bar_echelle.setUnitLabel("km")
            bar_echelle.setUnitsPerSegment(0.5)

        elif echelle.scale() >= 9000:
            bar_echelle.setUnits(QgsUnitTypes.DistanceMeters)
            bar_echelle.setUnitLabel("m")
            bar_echelle.setUnitsPerSegment(250)

        elif echelle.scale() >= 5000:
            bar_echelle.setUnits(QgsUnitTypes.DistanceMeters)
            bar_echelle.setUnitLabel("m")
            bar_echelle.setUnitsPerSegment(100)

        else:
            bar_echelle.setUnits(QgsUnitTypes.DistanceMeters)
            bar_echelle.setUnitLabel("m")
            bar_echelle.setUnitsPerSegment(50)

        bar_echelle.update()

    def popup_resolution(self):

        self.dialog = OptionsWindow()
        self.dialog.show()

map_cen_instance = MapCEN(iface)